#filtering AQ components from teh main dataset.
#the removing non-75% completeness compliant sensors.
#then identifying outliers
#I can remove the outlier one for now and come back to them later. Perform the pm10 correlation with the no-issue sensors first.
#then separating the datasets into pre-2024 and post-2024
#XOXOXOX so now that I have seperated the values into pre-and-post i now need to deal with outliers.
####add median, add
#then another split of the data. Replace outliers with NA. Then separately set them to teh 99th percentile.
#report on quartile values for each designated timeframe, 25th/75th for each season in the years.
#do this separately for each pollutant

all_data <- read.csv("U:/1. RDFV data work/AQ components subdataframes/sensoren_rdfv_IRAS.csv")

pacman::p_load(data.table, tidyverse, lubridate, openair, tidyr, randomForest, ggplot2, 
               dplyr, beepr, curl, jsonlite, ggcorrplot, reshape2, paletteer)
setwd("U:/1. RDFV data work/AQ components subdataframes")


alldata <- read_csv("U:/RDFV data work/AQ components subdataframes/Widened raw sensor dataset.csv")
pm25_hc <- read_csv("U:/RDFV data work/AQ components subdataframes/PM2.5_high_completeness_df - Copy.csv")
no2_completeness_by_time <- read_csv("U:/RDFV data work/AQ components subdataframes/no2_completeness by time df non_neg.csv")


#isolate analyte rows to be tested.
raw_pm25 <- widerawdf [widerawdf$Measurement == "pm25", ]
raw_pm10 <- widerawdf [widerawdf$Measurement == "pm10", ]
raw_no2 <- widerawdf [widerawdf$Measurement == "no2", ]

??geom_boxplot


pm25_hc <- read_csv("U:/1. RDFV data work/AQ components subdataframes/PM2.5_high_completeness_df - Copy.csv")
no2_hc <- read_csv("U:/1. RDFV data work/AQ components subdataframes/NO2_high_completeness_df_2.csv")
library(readr)
pm10hc <- read_csv("PM10_high_completeness_df.csv")
percentile_counts_pm10 <- read_csv("U:/1. RDFV data work/AQ components subdataframes/WIP_percentile_counts_pm10_hc75.csv")

View(pm10hc)
str(pm10hc)


#for PM2.5 remove 064 and X cols
pm25_hc$SSK_RDFV064 <- NULL
pm10hc$X <- NULL
pm10hc$...1 <- NULL



# Convert 'timestamp_from' to Date class
pm10hc <- pm10hc %>%
  mutate(timestamp_from = ymd_hms(timestamp_from))




# Extract month and year from the 'date' column
pm10_monthly <- pm10hc %>%
  mutate(month = format(timestamp_from, "%Y-%m"))  # Format date to 'YYYY-MM'



pm10hc <- pm10hc %>%
  mutate(
    year = as.factor(format(timestamp_from, "%Y")),  # if you'd like it as a factor
    month = as.factor(format(timestamp_from, "%m")) # or a factor for ordering
  )


########I've come upon an error. I think I need to split year and month in order to boxplot them.


str(pm10_rm_later_long)





#seperate data frame into pre- and post-'24
str(long_df)

(pm10_long$value[pm10_long$sensor == "SSK_RDFV049"])



#i want the values of all rows until teh timestamp_from = a certain date
#for the matrices sub-set the wide whole sensor data, not the long whole sensor data.
pm10hc_rm <- pm10hc %>%
  select(-c(SSK_RDFV016, SSK_RDFV007, SSK_RDFV007 ,
            SSK_RDFV020, SSK_RDFV023,SSK_RDFV030,
            SSK_RDFV037, SSK_RDFV049 ))

pm10hc_rm$SSK_RDFV016 <- NULL
pm10hc_rm$SSK_RDFV007 <- NULL
pm10hc_rm$SSK_RDFV020 <- NULL
pm10hc_rm$SSK_RDFV023 <- NULL
pm10hc_rm$SSK_RDFV030 <- NULL
pm10hc_rm$SSK_RDFV037 <- NULL
pm10hc_rm$SSK_RDFV049 <- NULL

str(pm10hc_rm)
summary(pm10hc_rm)

# Set desired percentiles (e.g., 1st and 99th)
lower_percentile <- 0.01
upper_percentile <- 0.99

# Function to calculate percentiles and counts for each numeric column
pm10_get_percentiles_and_counts <- function(pm10hc_rm, probs = c(lower_percentile, upper_percentile)) {
  numeric_data <- pm10hc_rm[sapply(pm10hc_rm, is.numeric)]
  
  results <- lapply(names(numeric_data), function(colname) {
    col <- numeric_data[[colname]]
    qs <- quantile(col, probs = probs, na.rm = TRUE)
    
    below <- sum(col < qs[1], na.rm = TRUE)
    above <- sum(col > qs[2], na.rm = TRUE)
    
    data.frame(
      Column = colname,
      LowerPercentile = qs[1],
      UpperPercentile = qs[2],
      CountBelow = below,
      CountAbove = above,
      stringsAsFactors = FALSE
    )
  })
  
  # Combine into a single dataframe
  result_df <- do.call(rbind, results)
  return(result_df)
}

# Run the function
percentile_counts_pm10 <- pm10_get_percentiles_and_counts(pm10hc_rm, 
                                                          probs = c(lower_percentile, upper_percentile))

# Print result
view(percentile_counts_pm10)

write.csv(percentile_counts_pm10, "pm10_percentile_counts_hc_rm.csv")


# ---- Assume df and percentile_counts are already loaded ----

# Function to replace outliers with NA (value-wise, not row-wise)
replace_outliers_with_na <- function(pm10hc_rm, thresholds_df) {
  data_clean <- pm10hc_rm
  total_values <- 0
  outlier_count <- 0
  
  for (i in 4:nrow(thresholds_df)) {
    col <- thresholds_df$Column[i]
    lower <- thresholds_df$LowerPercentile[i]
    upper <- thresholds_df$UpperPercentile[i]
    
    if (col %in% names(data_clean) && is.numeric(data_clean[[col]])) {
      col_values <- data_clean[[col]]
      is_outlier <- col_values < lower | col_values > upper
      
      outlier_count <- outlier_count + sum(is_outlier, na.rm = TRUE)
      total_values <- total_values + length(col_values)
      
      # Replace outliers with NA
      data_clean[[col]][is_outlier] <- NA
    }
  }
  
  loss_pct <- round(outlier_count / total_values * 100, 2)
  cat("Total values checked:", total_values, "\n")
  cat("Outliers replaced with NA:", outlier_count, "\n")
  cat("Percent of values replaced:", loss_pct, "%\n")
  
  return(data_clean)
}

# Apply the function
pm10_outlier_rm <- replace_outliers_with_na(pm10hc_rm, percentile_counts_pm10)



#seperate outlier-removed dataset into pre-and post-2024
pm10_rmwide_early <- pm10_outlier_rm%>%
  filter(timestamp_from < as.POSIXct("2024-01-01 01:00:00"))

pm10_rmwide_later <- pm10_outlier_rm %>%
  filter(timestamp_from >= as.POSIXct("2024-01-01 01:00:00"))



#Set outliers to threshold
set_outliers_to_threshold <- function(pm10hc_rm, thresholds_df) {
  data_clean <- pm10hc_rm
  total_values <- 0
  outlier_count <- 0
  
  for (i in 3:nrow(thresholds_df)) {
    col <- thresholds_df$Column[i]
    lower <- thresholds_df$LowerPercentile[i]
    upper <- thresholds_df$UpperPercentile[i]
    
    if (col %in% names(data_clean) && is.numeric(data_clean[[col]] )) {
      col_values <- data_clean[[col]]
      is_low_outlier <- col_values < lower
      is_high_outlier <- col_values > upper
      
      outlier_count <- outlier_count + sum(is_low_outlier | is_high_outlier, na.rm = TRUE)
      total_values <- total_values + length(col_values)
      
      # Set outliers to respective threshold
      data_clean[[col]][is_low_outlier] <- lower
      data_clean[[col]][is_high_outlier] <- upper
    }
  }
  
  pct_replaced <- round(outlier_count / total_values * 100, 2)
  cat("Total values checked:", total_values, "\n")
  cat("Outliers set to threshold:", outlier_count, "\n")
  cat("Percent of values set:", pct_replaced, "%\n")
  
  return(data_clean)
}

# Apply the function
pm10_outlier_to_threshold <- set_outliers_to_threshold (pm10hc_rm, percentile_counts_pm10)


pm10hc_rm

#seperate bad sensor-removed dataset into pre-and post-2024
pm10wide_early <- pm10_outlier_to_threshold %>%
  filter(timestamp_from < as.POSIXct("2024-01-01 01:00:00"))

pm10wide_later <- pm10_outlier_to_threshold%>%
  filter(timestamp_from >= as.POSIXct("2024-01-01 01:00:00"))



write.csv(pm10wide_early, "PM10hc_threshold_wide_pre-2024")
write.csv(pm10wide_later, "PM10hc_threshold_wide_post-2024.csv")

str(pm10hc_rm)

getwd()

pm10hc_rm

##rough idea of graphing no-outlier capping or removal
pm10_no_rm <- pm10hc_rm %>%
  select(-c(X, timestamp_from, Measurement, month, year, ...1))

#For the matrices delete non-sensor cols.
pm10_early_precorr <- pm10wide_early %>%
  select(-c(X, timestamp_from, Measurement, month, year, ...1))
pm10_later_precorr <- pm10wide_later %>%
  select(-c(X, timestamp_from, Measurement, month, year, ...1))


pm10_rm_early_precorr <- pm10_rmwide_early %>%
  select(-c(X, timestamp_from, Measurement, month, year, ...1))
pm10_rm_later_precorr <- pm10_rmwide_later %>%
  select(-c(X, timestamp_from, Measurement, month, year, ...1))


#no-outlier corrections
pm10_no_rm_correlation_matrix_spearman <- cor(pm10_no_rm, 
                                              use = "pairwise.complete.obs", method = 'spearman')
pm10_no_rm_correlation_matrix_pearson <- cor(pm10_no_rm,
                                             use = "pairwise.complete.obs", method = 'pearson')

#outlier-capped correlations
pm10_early_correlation_matrix_spearman <- cor(pm10_early_precorr, 
                                        use = "pairwise.complete.obs", method = 'spearman')
pm10_early_correlation_matrix_pearson <- cor(pm10_early_precorr, 
                                       use = "pairwise.complete.obs", method = 'pearson')

pm10_later_correlation_matrix_spearman <- cor(pm10_later_precorr, 
                                              use = "pairwise.complete.obs", method = 'spearman')
pm10_later_correlation_matrix_pearson <- cor(pm10_later_precorr, 
                                             use = "pairwise.complete.obs", method = 'pearson')


####outlier-removed corr matrices #########################
pm10_rm_early_correlation_matrix_spearman <- cor(pm10_rm_early_precorr , 
                                              use = "pairwise.complete.obs", method = 'spearman')
pm10_rm_early_correlation_matrix_pearson <- cor(pm10_rm_early_precorr,  
                                             use = "pairwise.complete.obs", method = 'pearson')

pm10_rm_later_correlation_matrix_spearman <- cor(pm10_rm_later_precorr, 
                                              use = "pairwise.complete.obs", method = 'spearman')
pm10_rm_later_correlation_matrix_pearson <- cor(pm10_rm_later_precorr, 
                                             use = "pairwise.complete.obs", method = 'pearson')


# Visualize the correlation matrix using a heatmap
#function for correlation heatmap plotting - for brevity
plot_correlation_heatmap <- function(cor_matrix, title, fill_label) {
  ggplot(melt(cor_matrix), aes(Var1, Var2, fill = value)) +
    geom_tile() +
    scale_fill_gradient(low = "cyan", high = "darkslategrey", limit = c(0, 1)) +
    theme_minimal() +
    labs(title = title, x = "Sensors", y = "Sensors", fill = fill_label) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}


plot_correlation_heatmap(pm10_no_rm_correlation_matrix_pearson,
                         "PM10 all-data, no-outlier removal Correlation Heatmap (Pearson)",
                         "Pearson Correlation")

plot_correlation_heatmap(pm10_early_correlation_matrix_spearman,
                         "PM10 all-data, no-outlier removal Correlation Heatmap (Spearman)",
                         "Spearman Correlation")




######OUTLIER-CAPPED CORPLOTTING
plot_correlation_heatmap(pm10_early_correlation_matrix_pearson,
                         "PM10 pre-2024 outlier-capped Correlation Heatmap (Pearson)",
                         "Pearson Correlation")

plot_correlation_heatmap(pm10_early_correlation_matrix_spearman,
                         "PM10 pre-2024 outlier-capped Correlation Heatmap (Spearman)",
                         "Spearman Correlation")

plot_correlation_heatmap(pm10_later_correlation_matrix_pearson,
                         "PM10 post-2024 outlier-capped Correlation Heatmap (Pearson)",
                         "Pearson Correlation")

plot_correlation_heatmap(pm10_later_correlation_matrix_spearman,
                         "PM10 post-2024 outlier-capped Correlation Heatmap (Spearman)",
                         "Spearman Correlation")

ggsave("PM10_corrplot_capped_post2024_spearman.png", 
       path = "U:/1. RDFV data work/graphs", 
       width = 10, height = 10, device='png', dpi=1000)

####SAME AS ABOVE BUT FOR OUTLIER-REMOVED SENSOR DATA
plot_correlation_heatmap(pm10_rm_early_correlation_matrix_pearson,
                         "PM10 pre-2024 outlier-removed Correlation Heatmap (Pearson)",
                         "Pearson Correlation")

plot_correlation_heatmap(pm10_rm_early_correlation_matrix_spearman,
                         "PM10 pre-2024 outlier-removed Correlation Heatmap (Spearman)",
                         "Spearman Correlation")

plot_correlation_heatmap(pm10_rm_later_correlation_matrix_pearson,
                         "PM10 post-2024 outlier-removed Correlation Heatmap (Pearson)",
                         "Pearson Correlation")

plot_correlation_heatmap(pm10_rm_later_correlation_matrix_spearman,
                         "PM10 post-2024 outlier-removed Correlation Heatmap (Spearman)",
                         "Spearman Correlation")

ggsave("PM10_corrplot_rm_post24_pearson.png", 
       path = "U:/1. RDFV data work/graphs", 
       width = 8, height = 8, device='png', dpi=1000)



write.csv(pm10_correlation_matrix_spearman, "pm10_early_corr_matrix_spearman.csv")
write.csv(pm10_correlation_matrix_pearson, "pm10_full_corr_matrix_pearson.csv")

####CURRENT

#-c(X, timestamp_from, Measurement, month, year, ...1)) 
#for refernce when pivoting longer

#turn hc dataframes long.
pm10_rm_early_long <- pm10_rmwide_early %>% 
  pivot_longer(
    cols = -c(X, timestamp_from, Measurement, month, year, ...1), 
    names_to = "sensor",
    values_to = "value"
  )

pm10_rm_later_long <- pm10wide_later %>% 
  pivot_longer(
    cols = 5:34, 
    names_to = "sensor",
    values_to = "value"
  )


##### this comes after separation of years
ggplot(pm10_rm_early_long, aes(x = sensor, y = value, fill = factor(year))) +
  geom_boxplot(outlier.size = 0.8, position = position_dodge(width = 0.75)) +
  labs(title = "PM10 high-complete, pre-2024, outlier-removed",
       x = "Sensor", y = "Sensor Value",
       fill = "Year") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        strip.text = element_text(size = 12))

ggsave("pm10_boxplot_pre-24_outlier-rm_.png", 
       path = "U:/1. RDFV data work/graphs", 
       width = 10, height = 10, device='png', dpi=1000)

summary(pm10_no_rm)


#graph and trendline outlier sensors
hist(pm10_long$value[pm10_no_rm$sensor == "SSK_RDFV048"])
ggsave("pm10_hist_senso48.png", 
       path = "U:/1. RDFV data work/graphs", 
       width = 8, height = 8, device='png', dpi=1000)

pm10_filtered <- pm10_long %>%
  filter(sensor == "SSK_RDFV048")

# Create the line plot
ggplot(pm10_filtered, aes(x = timestamp_from, y = value)) +
  geom_line(color = "steelblue") +
  labs(title = "PM10 Over Time - SSK_RDFV048",
       x = "Timestamp",
       y = "PM10 Value") +
  theme_minimal()



hist(pm10_long$sensor)
ggsave()

#### change extreme values to the 99th percentile not remove them. Same for 1st percentile.
#isolate the pollution of interest, identify and isolate sensors with >75% completeness.
#change values above 99 percentile to the 99 percentile
#find average







